# 算法与数据结构

[TOC]

## 时间复杂度

- **冒泡排序**

  相邻两个数比较，每轮将最大数的放到最后

- **选择排序**

  每次选择出最小的数的索引，每轮最后进行一次交换

- **异或运算理解：**

  无进位相加

  - 0 ^N = N

  - 满足交换律和结合律

  - 异或顺序可以任意

    ```
    #交换两个数 两个变量不能指向同一块内存区域
    a = a ^ b
    b = a ^ b
    a = a ^ b
    ```

  - > 通过异或算法寻找，一个数组中只有一种数出现奇数次和两种数出现奇数次
    >
    > 1. 只有一种奇数次的数
    >
    >    ```
    >    err = 0 
    >    err ^ = 数组中的每个数
    >    err最后的值就是那个出现奇数次的值
    >    ```
    >
    > 2. 两种奇数次的数
    >
    >    ```
    >    分两步
    >    第一步：
    >    err = 0
    >    err ^= 数组中每个数 
    >    err = a ^ b # (a,b表示出现次数为奇数次的两个数)
    >    第二步：
    >    rightone = err & (~err + 1) # 源码与补码想与得到最右边的1
    >    err_
    >    for num in nums:
    >    	if num & rightone: # 通过rightone将数组中这一位为1的数取出来
    >    		err_ ^= num 
    >    a,b分别为err_,err_^err
    >    ```

  - 源码与补码想与得到最右边的1

- **插入排序**

  - 每轮维持一个有序的数组，无序就插入到有序的位置

- **二分查找法**

  - 有序数组查找,  $ log_2 N $  

  - > 1. 查找某个数的第一次出现位置
    >
    >    ```
    >    正常使用有序数组中的二分法，但是每次二分时，记录二分的值，比较出最左边的位置
    >    ```
    >
    > 2. 无序，相邻数一定不相等，局部最小值
    >
    >    ```
    >    求解极小值的方法
    >    首先判断是否存在极小值，如果左端时下降趋势，右端时上升趋势（某个高数中的定理，我忘了）
    >    利用二分法，找中间的值
    >    	如果中间值小于两侧，找到极小值
    >    	如果中间值大于左侧，继续在左端和中间值中，找极小值
    >    	如果中间值大于右侧，继续在中间值和右端中，找极小值
    >    ```
  
- **对数器**

  - 随机样本产生器，测试算法正确性

- **递归行为**

  - master公式：

  $$
  T(N) = a * T(\frac {N}{b}) + O(N^d)
  $$

  $$
  
  log(b,a) > d，复杂度为O(N^{log(b,a)}) \\
  log(b,a) = d, 复杂度为O(N^d*logN)  \\
  log(b,a) < d, 复杂度为O(N^d)  \\
  $$

  

## `Nlog(n)`的排序

- 归并排序
  - 时间复杂度O(N*logN)，额外空间复杂度O(N)
- 快速排序
  - 荷兰国旗问题 
  - 决定一个pivot位置
  - 决定值相同的pivot位置
  - 随机pivot进行划分

## 桶排序和排序内容大总结

- 堆排序
  - 数组按照完全二叉树排列
  - heapify:从上往下比较，使得堆结构成立
  - heapinsert:从下往上比较，使得堆结构成立
  - 实现步骤：
    - 编写Heap类，实例属性有`self.heap,self.size`
    - 方法有：
      - `push(self,val)`，送入堆，用到`shiftup`
      - `shiftup(self,n)`，从节点n，向上调整堆
      - `peek(self)`，取出堆顶元素
      - `pop(self)`,弹出堆顶元素，从节点1，向下调整
      - `shiftdown(self,n)`，从节点n，向下调整
      - `heapSort(self,nums)`，先初始化堆，然后依次取出堆顶、调整，得到有序数组
- 几乎有序的数组的排序
- 比较器：
  - 重载compare函数
- 计数排序
- 基数排序
  - 实现步骤：
    - 主函数，`radixSort(nums)`
    - 获取最大位数函数，`MaxDigit(nums)`
    - 获取某个数d位上的值，`getDigit(num,d)`
    - 利用桶排序思想的`radixsort(nums,l,r,maxdigit)`
      - `l,r`表示桶排序数组的范围
      - `maxdigit`轮桶排序
      - 每一轮给每个桶中的数的个数计数
      - 出桶到临时数组，然后重写到`nums`

## 链表

## 二叉树

## 图

## 前缀树和贪心算法

## 暴力递归

## 哈希函数和哈希表

## KMP、Manacher算法

## 滑动窗口、单调栈

## 二叉树的Morris遍历

## 大数据题目

## 暴力递归

